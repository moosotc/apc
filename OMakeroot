OMakeFlags (-w)

.ORDER: .caml-order
.caml-order: %.cmi: %.cmo
.caml-order: %.cmx: %.cmo

caml-sort(files) =
    return $(file-sort .caml-order, $(files))

collect-includes(flags) =
    dirs[] =
    next = false
    foreach (f, $(flags))
        if $(next)
            dirs += $f
            next = false
            export
        else
            f = $(string $f)
            l = $(f.length)
            if $(and $(gt $l, 1), \
                     $(and $(equal $(f.nth 0), -), \
                           $(equal $(f.nth 1), I)))
                if $(gt $l, 2)
                    dirs += $(removeprefix -I, $f)
                    export
                else
                    next = true
                    export
                export
            export
        export
    return $(dirs)

Shell. +=
    pr-list(argv) =
        foreach(a, $(argv))
            println($a)

    eecho(argv) =
        eprintln($(string $(argv)))

    cmo-scan(argv) =
        emacs-helper = directory $"`"$(absname $(dirof $<))\'
        eecho "make[0]: Entering $(emacs-helper)"
        cd $(dirof $<)
        ocamldep $(depflags) $(basename $<)
        eecho "make[0]: Leaving $(emacs-helper)"

    cmx-scan(argv) =
        emacs-helper = directory $"`"$(absname $(dirof $<))\'
        eecho "make[0]: Entering $(emacs-helper)"
        cd $(dirof $<)
        ocamldep $(depflags) $(basename $<)
        eecho "make[0]: Leaving $(emacs-helper)"

ocamlc(name, flags) =
    s = $(name).ml
    i = $(name).mli
    o = $(name).cmo
    I = $(name).cmi

    depflags = $(mapprefix -I, $(collect-includes $(flags)))

    .SCANNER: %.cmo.scan: %.ml
        cmo-scan

    if $(file-exists $i)
        .SCANNER: %.cmi.scan: %.mli
            cmo-scan

        $o: $I
        $I: $i :scanner: $I.scan
            ocamlc $(flags) -c -o $I $(absname $i)

        $o: $s :scanner: $o.scan
            ocamlc $(flags) -c -o $o $(absname $s)
    else
        $o $I: $s :scanner: $o.scan
            ocamlc $(flags) -c -o $o $(absname $s)

ocamlopt(name, flags) =
    s = $(name).ml
    i = $(name).mli
    o = $(name).cmx
    I = $(name).cmi
    O = $(name).o

    depflags = $(mapprefix -I, $(collect-includes $(flags)))

    .SCANNER: %.cmx.scan: %.ml
        cmx-scan

    if $(file-exists $i)
        .SCANNER: %.cmi.scan: %.mli
            cmx-scan

#        $o: $I
#        $I: $i :scanner: $I.scan
#            ocamlopt $(flags) -c -o $I $(absname $i)

        $o $O: $s :scanner: $o.scan
            ocamlopt $(flags) -c -o $o $(absname $s)
    else
        $o $O: $s :scanner: $o.scan
            ocamlopt $(flags) -c -o $o $(absname $s)

Mocamlc(names, flags) =
    foreach (n, $(names))
        ocamlc ($n, $(flags))

Mocamlopt(names, flags) =
    foreach (n, $(names))
        ocamlopt ($n, $(flags))

cc(name, flags) =
    s = $(name).c
    o = $(name).o

    .SCANNER: %.o.scan: %.c
        gcc $(flags) -MM -MT $* $<

    $o: $s :scanner: $o.scan
        gcc $(flags) -c -o $@ $<

ocamlcc(name, flags) =
    s = $(name).c
    o = $(name).o

    .SCANNER: %.o.scan: %.c
        ocamlc -ccopt "$(flags) -MM -MT $o" -cc gcc $<

    $o: $s :scanner: $o.scan
        ocamlc -ccopt "$(flags) -o $o" -cc gcc $<

Mcc(names, flags) =
    foreach (n, $(names))
        cc($n, $(flags))

Mocamlcc(names, flags) =
    foreach (n, $(names))
        ocamlcc($n, $(flags))

if $(not $(defined srcdir))
    srcdir = $(absname $(dirof OMakeroot))
    export srcdir

mkdir -p build
add-project-directories (build .)
vmount ($(srcdir), build)
.SUBDIRS: build
