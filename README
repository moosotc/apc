~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is APC - graphical CPU load meter.

It is more suitable/accurate in situations where applications generate
"short" periodic bursts of activity.

It works by timing the time spent in the kernels idle handler. CPU
load time is taken to mean:
     time spent in idle handler
1 -  --------------------------
        total time elapsed

Kernel can use variety of values for HZ (most frequent: 100 250 1000)

PAL/SECAM video frame grabbers do so with  25/50 FPS frequency, if the
pulse leads to   some application deciding  to  burn CPU (putting  the
frame on the screen, encoding it, etc) chances  are good that the load
you will  see  in top(1)  (or anything  `/proc/stat' based) would  not
represent reality  accurately. Ditto for plain  video clips playing at
25 fps.

When   frequency of aforementioned    bursts  devides HZ value  evenly
reading `/proc/stat'  or `/proc/uptime'  can  make an  impression that
sometimes machine gets loaded for a brief period of time but then goes
idle again (for a while) then the cycle repeats. This is not the case,
the machine  is constantly loaded (well  according to ad-hoc measuring
via background niced process and/or APC)

If this line of thinking is correct one can not notice any load at all
while watching  NTSC  content  (30fps - does not  divide  100/250/1000
evenly)

Furthermore `/proc/stat'  exports monotonically increasing  load times
but _NOT_  real time[1], so  there's omni-present sub-jiffy error. Not
to mention that jiffy resolution is somewhat low.

If you  depend  on  sorta-kinda   semi-correct  load  meter  in  those
conditions APC might present a better choice.

The kernel  module   part of APC  measures  how  much time   is  spent
executing idle kernel function   - this information is  represented by
yellow color, values obtained via `/proc/stat' are represented by red.

You  can use `-help' command  line option to   get a brief overview of
tunable parameters.

Tested on[2]:

Linux 2.4.30   - AMD Athlon(tm) Processor (1.4 Ghz)
Linux 2.6.17.6 - AMD Athlon(tm)64 X2 Dual Core Processor  3800+
Linux 2.6.18   - AMD Athlon(tm)64 3800+
Linux 2.6.18.3 - PowerPC 7447A

It's possible  that RMClock[3]  does something similar(load  measuring
wise) on Microsoft Windows.

[1] Unlike `/proc/uptime'. But this one is useless for SMP
[2] SMP not tested on 2.4 kernels, nor QUIRK mode. SMP on PPC wasn't
    tested at all
[3] http://cpu.rightmark.org/products/rmclock.shtml

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To build you will need:

OCaml  - http://caml.inria.fr/ocaml/
LablGL - http://wwwfun.kurims.kyoto-u.ac.jp/soft/lsl/lablgl.html
         (and by extension some OpenGL implementation)
GLUT   - http://www.opengl.org/resources/libraries/glut/
         http://freeglut.sourceforge.net/
GCC    - http://gcc.gnu.org/

Plus all what is required to build a kernel module.

Process:

<untar and go to directory with sources>
$ sh build.sh
$ cd mod
$ su -c 'insmod ./its.ko' - 2.6 Kernels
$ su -c 'insmod ./its.o'  - 2.4 Kernels

Following applies only to Linux running on X86.

If the module fails to load consult dmesg(8). Most likely cause is the
lack  of  exported `default_idle'    function  and no   specific power
management idle function is specified. Few workarounds follow:

Variant 1
    Add `idle=halt' to the kernel command  line (method depends on the
    boot-loader) and reboot.

Variant 2 (DANGEROUS)
    ------------------------------------------------------------------
    Kernel 2.6
    $ func=$(awk '/default_idle$/ {print "0x" $1}' /proc/kallsyms)
    $ su -c "insmod ./itc.ko idle_func=$func"

    ------------------------------------------------------------------
    Kernel 2.4
    $ func=$(awk '/default_idle$/ {print "0x" $1}' /proc/ksyms)
    $ su -c "insmod ./itc.o idle_func=$func"

======================================================================
$ cd ..
$ major=$(awk '/ itc$/ {print $1}' /proc/devices)
$ su -c "mknod -m 0444 itc c $major 0"

[make sure you are in X]
$ ./apc
